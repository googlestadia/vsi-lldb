// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using DebuggerApi;
using Metrics.Shared;
using Microsoft.VisualStudio;
using NSubstitute;
using NUnit.Framework;
using YetiVSI.DebugEngine;

namespace YetiVSI.Test.DebugEngine
{
    [TestFixture]
    class ModuleFileLoaderTests
    {
        const string _binaryFilename = "test";
        int _moduleId = 0;
        const string _platformDirectory = "/path/bin";
        const string _loadOutput = "Load output.";
        static readonly string[] _importantModules = new[]
        {
            "libc-2.24.so", "libc.so", "libc.so.6", "libc-2.24.so.6", "libBrokenLocale.so.1",
            "libutil.so", "libc++.so", "libc++abi.so", "libggp.so", "libvulkan.so",
            "libpulsecommon-12.0.so", "amdvlk64.so", "libdrm.so", "libdrm_amdgpu.so",
            "libidn.so", "libnettle.so",
        };

        ICancelable _mockTask;
        SbFileSpec _mockPlatformFileSpec;
        IModuleFileLoadMetricsRecorder _mockModuleFileLoadRecorder;
        ISymbolLoader _mockSymbolLoader;
        IBinaryLoader _mockBinaryLoader;
        ModuleFileLoader _moduleFileLoader;
        IModuleSearchLogHolder _moduleSearchLogHolder;

        [SetUp]
        public void SetUp()
        {
            _mockTask = Substitute.For<ICancelable>();
            _mockPlatformFileSpec = Substitute.For<SbFileSpec>();
            _mockPlatformFileSpec.GetDirectory().Returns(_platformDirectory);
            _mockPlatformFileSpec.GetFilename().Returns(_binaryFilename);
            _mockSymbolLoader = Substitute.For<ISymbolLoader>();
            _mockBinaryLoader = Substitute.For<IBinaryLoader>();
            _moduleSearchLogHolder = new ModuleSearchLogHolder();
            _moduleFileLoader = new ModuleFileLoader(_mockSymbolLoader, _mockBinaryLoader,
                                                    false, _moduleSearchLogHolder);
            _mockModuleFileLoadRecorder = Substitute.For<IModuleFileLoadMetricsRecorder>();
        }

        // Need to assign test name since otherwise the autogenerated names would clash, e.g.
        // "LoadModuleFiles(0,System.Boolean[])" for the first two.
        [TestCase(VSConstants.S_OK, new bool[] {},
            TestName = "LoadModuleFilesSucceeds_NoModules")]
        [TestCase(VSConstants.S_OK, new[] { true },
            TestName = "LoadModuleFilesSucceeds_SymbolLoadSucceeds")]
        [TestCase(VSConstants.E_FAIL, new[] { false },
            TestName = "LoadModuleFilesFails_SymbolLoadFails")]
        [TestCase(VSConstants.S_OK, new[] { true, true, true },
            TestName = "LoadModuleFilesSucceeds_SymbolLoadSucceeds3Times")]
        [TestCase(VSConstants.E_FAIL, new[] { true, false, true },
            TestName = "LoadModuleFilesFails_SymbolLoadSucceedsFailsSucceeds")]
        [TestCase(VSConstants.E_FAIL, new[] { false, false, false },
            TestName = "LoadModuleFilesFails_SymbolLoadFails3Times")]
        public async Task LoadModuleFilesAsync(int expectedReturnCode, bool[] loadSymbolsSuccessValues)
        {
            List<SbModule> modules = loadSymbolsSuccessValues
                              .Select(loadSymbolsSuccessValue => CreateMockModule(
                                          isPlaceholder: true, loadBinarySucceeds: true,
                                          loadSymbolsSucceeds: loadSymbolsSuccessValue))
                              .ToList();

            Assert.AreEqual(
                expectedReturnCode,
                (await _moduleFileLoader.LoadModuleFilesAsync(
                    modules, _mockTask, _mockModuleFileLoadRecorder)).ResultCode);

            foreach (SbModule module in modules)
            {
                await AssertLoadBinaryReceivedAsync(module);
                await AssertLoadSymbolsReceivedAsync(module);
            }

            int symbolsLoadedAfter = loadSymbolsSuccessValues.Count(x => x);
            _mockModuleFileLoadRecorder.Received()
                .RecordAfterLoad(Arg.Is<DeveloperLogEvent.Types.LoadSymbolData>(
                x =>
                x.ModulesBeforeCount == modules.Count
                && x.ModulesCount == modules.Count
                && x.ModulesAfterCount == modules.Count
                && x.ModulesWithSymbolsLoadedBeforeCount == 0
                && x.ModulesWithSymbolsLoadedAfterCount == symbolsLoadedAfter
                && x.BinariesLoadedBeforeCount == 0
                && x.BinariesLoadedAfterCount == modules.Count
                ));
        }

        [Test]
        public async Task LoadModuleFilesWithInclusionSettingsAsync()
        {
            SbModule includedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "included");
            SbModule excludedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "excluded");
            var modules = new List<SbModule> { includedModule, excludedModule };

            bool useIncludeList = true;
            var includeList = new List<string>() { "included" };
            var settings =
                new SymbolInclusionSettings(useIncludeList, new List<string>(), includeList);

            Assert.That(
                (await _moduleFileLoader.LoadModuleFilesAsync(
                    modules, settings, true, true, _mockTask, _mockModuleFileLoadRecorder))
                    .ResultCode,
                Is.EqualTo(VSConstants.S_OK));

            await AssertLoadBinaryReceivedAsync(includedModule);
            await AssertLoadSymbolsReceivedAsync(includedModule);
            await AssertLoadBinaryNotReceivedAsync(excludedModule);
            await AssertLoadSymbolsNotReceivedAsync(excludedModule);
        }

        [Test]
        public async Task LoadModuleFilesWithExclusionSettingsAsync()
        {
            SbModule includedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "included");
            SbModule excludedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "excluded");
            var modules = new List<SbModule> { includedModule, excludedModule };

            bool useIncludeList = false;
            var excludeList = new List<string> { "excluded" };
            var settings =
                new SymbolInclusionSettings(useIncludeList, excludeList, new List<string>());

            Assert.That(
                (await _moduleFileLoader.LoadModuleFilesAsync(
                    modules, settings, true, true, _mockTask, _mockModuleFileLoadRecorder))
                    .ResultCode,
                Is.EqualTo(VSConstants.S_OK));

            await AssertLoadBinaryReceivedAsync(includedModule);
            await AssertLoadSymbolsReceivedAsync(includedModule);
            await AssertLoadBinaryNotReceivedAsync(excludedModule);
            await AssertLoadSymbolsNotReceivedAsync(excludedModule);
        }

        [Test]
        public async Task SearchLogsAreResetBetweenLoadModuleFilesAttemptsAsync()
        {
            SbModule includedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "included");
            SbModule excludedModule = CreateMockModule(
                true, loadBinarySucceeds: true,
                loadSymbolsSucceeds: true, name: "excluded");
            var modules = new List<SbModule> { includedModule, excludedModule };

            bool useIncludeList = false;
            var excludeList = new List<string> { "excluded" };
            var settings =
                new SymbolInclusionSettings(useIncludeList, excludeList, new List<string>());

            // 1. Run LoadSymbols with the settings, excluding the `excludedModule`.
            await _moduleFileLoader.LoadModuleFilesAsync(
                modules, settings, false, false, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual("Symbol loading disabled by Include/Exclude setting.",
                            _moduleSearchLogHolder.GetSearchLog(excludedModule));
            Assert.AreEqual("", _moduleSearchLogHolder.GetSearchLog(includedModule));

            // 2. Settings are null, so both modules will be loaded.
            await _moduleFileLoader.LoadModuleFilesAsync(
                modules, null, false, false, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual("",
                            _moduleSearchLogHolder.GetSearchLog(excludedModule));
            Assert.AreEqual("", _moduleSearchLogHolder.GetSearchLog(includedModule));

            // 3. Run LoadSymbols with the settings, excluding the `excludedModule`.
            await _moduleFileLoader.LoadModuleFilesAsync(
                modules, settings, false, false, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual("Symbol loading disabled by Include/Exclude setting.",
                            _moduleSearchLogHolder.GetSearchLog(excludedModule));
            Assert.AreEqual("", _moduleSearchLogHolder.GetSearchLog(includedModule));
        }

        [TestCase(false, 1)]
        [TestCase(true, 0)]
        public async Task LoadSymbolsIsCalledBasedOnHasSymbolsLoadedAsync(bool hasCompileUnits,
            int callsToLoadSymbolsAsync)
        {
            SbModule module = CreateMockModule(false);
            module.HasCompileUnits().Returns(hasCompileUnits);
            var modules = new List<SbModule>() { module };
            await _moduleFileLoader.LoadModuleFilesAsync(
                modules, null, false, false, _mockTask, _mockModuleFileLoadRecorder);
            await _mockSymbolLoader
                .Received(callsToLoadSymbolsAsync)
                .LoadSymbolsAsync(module, Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>());

        }

        [Test]
        public async Task LoadModuleFiles_AlreadyLoadedAsync()
        {
            SbModule module = CreateMockModule(isPlaceholder: true, loadBinarySucceeds: true,
                                               loadSymbolsSucceeds: true);

            Assert.AreEqual(VSConstants.S_OK, (await _moduleFileLoader.LoadModuleFilesAsync(
                new[] { module }, _mockTask, _mockModuleFileLoadRecorder)).ResultCode);
        }

        [Test]
        public async Task LoadModuleFiles_CanceledDuringLoadSymbolsAsync()
        {
            List<SbModule> modules = new[] {
                CreateMockModule(isPlaceholder: false),
                CreateMockModule(isPlaceholder: false),
            }.ToList();

            // Both modules have binaries loaded, but without symbols, we will try to locate
            // the corresponding symbols using `_symbolLoader.LoadSymbolsAsync`. This operation
            // is preceded by the check whether `_task` was cancelled.
            _mockTask.When(x => x.ThrowIfCancellationRequested())
                .Do(Callback
                        .First(x => { })
                        .ThenThrow(new OperationCanceledException()));

            Assert.ThrowsAsync<OperationCanceledException>(() =>
                _moduleFileLoader
                    .LoadModuleFilesAsync(modules, _mockTask, _mockModuleFileLoadRecorder));

            await _mockSymbolLoader.Received().LoadSymbolsAsync(
                modules[0], Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>());
            await _mockSymbolLoader.DidNotReceive().LoadSymbolsAsync(
                modules[1], Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>());
        }

        [Test]
        public async Task LoadModuleFiles_CanceledDuringLoadBinariesAsync()
        {
            List<SbModule> modules = new[] {
                CreateMockModule(isPlaceholder: true),
                CreateMockModule(isPlaceholder: true),
            }.ToList();

            // Both modules are placeholders, we will try to find real binaries in our system
            // using `_binaryLoader.LoadBinaryAsync`. This operation is preceded by the check
            // whether `_task` was cancelled.
            _mockTask.When(x => x.ThrowIfCancellationRequested())
                .Do(Callback
                        .First(x => { })
                        .ThenThrow(new OperationCanceledException()));

            Assert.ThrowsAsync<OperationCanceledException>(
                () => _moduleFileLoader
                    .LoadModuleFilesAsync(modules, _mockTask, _mockModuleFileLoadRecorder));

            await _mockBinaryLoader.Received().LoadBinaryAsync(
                modules[0], Arg.Any<TextWriter>());
            await _mockBinaryLoader.DidNotReceive().LoadBinaryAsync(
                modules[1], Arg.Any<TextWriter>());
        }

        [Test]
        public async Task LoadModuleFiles_LoadBinariesFailsAsync()
        {
            SbModule module = CreateMockModule(isPlaceholder: true);
            _mockBinaryLoader
                .LoadBinaryAsync(module, Arg.Any<TextWriter>())
                .Returns((module, false));
            Assert.AreEqual(VSConstants.E_FAIL, (await _moduleFileLoader.LoadModuleFilesAsync(
                new[] { module }, _mockTask, _mockModuleFileLoadRecorder)).ResultCode);

            await AssertLoadBinaryReceivedAsync(module);
            await _mockSymbolLoader.DidNotReceiveWithAnyArgs()
                .LoadSymbolsAsync(module, null,true, false);
        }

        [Test]
        public async Task LoadModuleFiles_ReplacedPlaceholderModuleAsync()
        {
            SbModule placeholderModule = CreateMockModule(isPlaceholder:true);
            SbModule realModule = CreateMockModule(isPlaceholder: false, loadSymbolsSucceeds: true);
            _mockBinaryLoader.LoadBinaryAsync(placeholderModule, Arg.Any<TextWriter>())
                .Returns(x => (realModule, true));
            _mockSymbolLoader.LoadSymbolsAsync(realModule, Arg.Any<TextWriter>(),
                                              Arg.Any<bool>(), Arg.Any<bool>())
                .Returns(Task.FromResult(true));
            SbModule[] modules = new[] { placeholderModule };

            Assert.AreEqual(VSConstants.S_OK, (await _moduleFileLoader.LoadModuleFilesAsync(
                modules, _mockTask, _mockModuleFileLoadRecorder)).ResultCode);

            await AssertLoadBinaryReceivedAsync(placeholderModule);
            await AssertLoadSymbolsReceivedAsync(realModule);
        }

        [Test]
        public async Task LoadModuleFiles_UnableToLoadImportantModuleForGameAttachAsync()
        {
            SbModule module = CreateMockModule(
                isPlaceholder: true, loadSymbolsSucceeds: true, name: _importantModules.First());
            _mockBinaryLoader
                .LoadBinaryAsync(module, Arg.Any<TextWriter>())
                .Returns((module, false));
            LoadModuleFilesResult result = await _moduleFileLoader.LoadModuleFilesAsync(
                new[] { module }, null, true, true, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual(VSConstants.E_FAIL, result.ResultCode);
            Assert.AreEqual(false, result.SuggestToEnableSymbolStore);
        }

        [Test]
        public async Task LoadModuleFiles_UnableToLoadImportantModuleForCrashDumpAsync()
        {
            foreach (string moduleName in _importantModules)
            {
                SbModule module = CreateMockModule(
                    isPlaceholder: true, loadSymbolsSucceeds: true, name: moduleName);
                _mockBinaryLoader
                    .LoadBinaryAsync(module, Arg.Any<TextWriter>())
                    .Returns((module, false));
                var dumpModuleFileLoader = new ModuleFileLoader(
                    _mockSymbolLoader, _mockBinaryLoader, true, _moduleSearchLogHolder);
                LoadModuleFilesResult result = await dumpModuleFileLoader.LoadModuleFilesAsync(
                    new[] { module }, null, false, false, _mockTask, _mockModuleFileLoadRecorder);

                Assert.AreEqual(VSConstants.E_FAIL, result.ResultCode, moduleName);
                Assert.AreEqual(true, result.SuggestToEnableSymbolStore, moduleName);
            }
        }

        [Test]
        public async Task LoadModuleFiles_UnableToLoadModuleForCrashDumpAsync()
        {
            SbModule module = CreateMockModule( true, loadSymbolsSucceeds: true);
            _mockBinaryLoader
                .LoadBinaryAsync(module, Arg.Any<TextWriter>())
                .Returns((module, false));
            var dumpModuleFileLoader = new ModuleFileLoader(_mockSymbolLoader, _mockBinaryLoader,
                                                            true, _moduleSearchLogHolder);
            LoadModuleFilesResult result = await dumpModuleFileLoader.LoadModuleFilesAsync(
                new[] { module }, null, false, false, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual(VSConstants.E_FAIL, result.ResultCode);
            Assert.AreEqual(false, result.SuggestToEnableSymbolStore);
        }

        [Test]
        public async Task LoadModuleFiles_DoNotShowSuggestionIfSymbolStoreEnabledAsync()
        {
            SbModule module = CreateMockModule(isPlaceholder: true, loadSymbolsSucceeds: true);
            _mockBinaryLoader
                .LoadBinaryAsync(module, Arg.Any<TextWriter>())
                .Returns((module, false));
            var dumpModuleFileLoader = new ModuleFileLoader(_mockSymbolLoader, _mockBinaryLoader,
                                                            true,
                                                            _moduleSearchLogHolder);
            LoadModuleFilesResult result = await dumpModuleFileLoader.LoadModuleFilesAsync(
                new[] { module }, null, true, true, _mockTask, _mockModuleFileLoadRecorder);

            Assert.AreEqual(VSConstants.E_FAIL, result.ResultCode);
            Assert.AreEqual(false, result.SuggestToEnableSymbolStore);
        }

        [Test]
        public async Task GetSearchLog_WhenBinaryLoadFailsAsync()
        {
            SbModule module = CreateMockModule(isPlaceholder: true, loadSymbolsSucceeds: true);
            module.GetPlatformFileSpec().Returns(_mockPlatformFileSpec);
            _mockBinaryLoader.LoadBinaryAsync(module, Arg.Any<TextWriter>()).Returns(x =>
            {
                x.Arg<TextWriter>().WriteLine(_loadOutput);
                // When the LoadBinaryAsync fails it returns the input module.
                return (module, false);
            });
            await _moduleFileLoader.LoadModuleFilesAsync(new[] { module }, _mockTask,
                _mockModuleFileLoadRecorder);

            StringAssert.Contains(_loadOutput, _moduleSearchLogHolder.GetSearchLog(module));
        }

        [Test]
        public async Task GetSearchLog_WhenBinaryLoadSucceedsAsync()
        {
            SbModule module = CreateMockModule(isPlaceholder: true, loadSymbolsSucceeds: true);
            module.GetPlatformFileSpec().Returns(_mockPlatformFileSpec);

            SbModule loadedModule = CreateMockModule(false);
            loadedModule.GetId().Returns(5);

            _mockBinaryLoader.LoadBinaryAsync(module, Arg.Any<TextWriter>()).Returns(x =>
            {
                x.Arg<TextWriter>().WriteLine(_loadOutput);
                // When the LoadBinaryAsync succeeds it returns the new module.
                return (loadedModule, true);
            });

            await _moduleFileLoader.LoadModuleFilesAsync(new[] { module }, _mockTask,
                                                         _mockModuleFileLoadRecorder);

            StringAssert.Contains(_loadOutput,
                                  _moduleSearchLogHolder.GetSearchLog(loadedModule));
        }

        [Test]
        public void GetSearchLog_NoPlatformFileSpec()
        {
            var mockModule = Substitute.For<SbModule>();
            mockModule.GetPlatformFileSpec().Returns((SbFileSpec)null);

            Assert.AreEqual("", _moduleSearchLogHolder.GetSearchLog(mockModule));
        }

        [Test]
        public void GetSearchLog_NoResult()
        {
            var mockModule = Substitute.For<SbModule>();
            mockModule.GetPlatformFileSpec().Returns(_mockPlatformFileSpec);

            Assert.AreEqual("", _moduleSearchLogHolder.GetSearchLog(mockModule));
        }

        async Task AssertLoadBinaryReceivedAsync(SbModule module)
        {
            await _mockBinaryLoader.Received().LoadBinaryAsync(module, Arg.Any<TextWriter>());
        }

        async Task AssertLoadSymbolsReceivedAsync(SbModule module)
        {
            await _mockSymbolLoader.Received().LoadSymbolsAsync(
                module, Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>());
        }

        async Task AssertLoadBinaryNotReceivedAsync(SbModule module)
        {
            await _mockBinaryLoader.DidNotReceive().LoadBinaryAsync(module, Arg.Any<TextWriter>());
        }

        async Task AssertLoadSymbolsNotReceivedAsync(SbModule module)
        {
            await _mockSymbolLoader.DidNotReceive().LoadSymbolsAsync(
                module, Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>());
        }

        /// <summary>
        /// Creates a new mock module, and configures mockBinaryLoader and mockSymbolLoader to
        /// return appropriate values for said module in the context of a call to LoadModuleFiles.
        /// The success values of LoadBinaries and LoadSymbols are directly determined by the values
        /// of |loadBinarySucceeds| and |loadSymbolsSucceeds|.
        /// </summary>
        SbModule CreateMockModule(bool isPlaceholder, bool loadBinarySucceeds = false,
                                  bool loadSymbolsSucceeds = false, string name = "some_name")
        {
            var module = Substitute.For<SbModule>();
            module.GetId().Returns(_moduleId++);
            module.GetPlatformFileSpec().GetFilename().Returns(name);
            if (isPlaceholder)
            {
                module.GetNumSections().Returns(1ul);
                module.FindSection(".module_image").Returns(Substitute.For<SbSection>());
                _mockBinaryLoader.LoadBinaryAsync(module, Arg.Any<TextWriter>())
                    .Returns(Task.FromResult((module, loadBinarySucceeds)));
            }
            _mockSymbolLoader
                .LoadSymbolsAsync(module, Arg.Any<TextWriter>(), Arg.Any<bool>(), Arg.Any<bool>())
                .Returns(Task.FromResult(loadSymbolsSucceeds));

            return module;
        }
    }
}
