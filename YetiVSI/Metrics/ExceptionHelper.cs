// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using GgpGrpc;
using GgpGrpc.Cloud.Interceptors;
using Grpc.Core;
using System;
using YetiCommon;
using YetiVSI.Shared.Metrics;

namespace YetiVSI.Metrics
{
    public static class ExceptionHelper
    {
        public static DeveloperLogEvent RecordException(Exception e)
        {
            if (e is RpcException)
            {
                return RecordRpcException((RpcException) e);
            }

            if (e is ProcessException)
            {
                return RecordProcessException((ProcessException)e);
            }

            var statusCode = ClassifyException(e);
            if (statusCode != DeveloperEventStatus.Types.Code.UnknownStatus)
            {
                return new DeveloperLogEvent {StatusCode = statusCode};
            }

            if (e.InnerException != null)
            {
                return RecordException(e.InnerException);
            }

            return new DeveloperLogEvent
            {
                StatusCode = DeveloperEventStatus.Types.Code.InternalError
            };
        }

        static DeveloperLogEvent RecordRpcException(RpcException e)
        {
            var logEvent = new DeveloperLogEvent();
            logEvent.StatusCode = ClassifyGrpcStatus(e.Status);

            var serviceName = e.Data[ErrorData.ServiceNameKey] as string;
            var methodName = e.Data[ErrorData.MethodNameKey] as string;
            var details =
                new GrpcServiceCallDetails
                {
                    Status = e.Status
                };
            if (!string.IsNullOrEmpty(serviceName))
            {
                details.ServiceName = serviceName;
            }
            if (!string.IsNullOrEmpty(methodName))
            {
                details.ServiceMethod = methodName;
            }
            logEvent.GrpcErrorDetails = details;
            return logEvent;
        }

        static DeveloperLogEvent RecordProcessException(ProcessException e)
        {
            var logEvent = new DeveloperLogEvent();
            if (e is ProcessExecutionException)
            {
                logEvent.StatusCode = DeveloperEventStatus.Types.Code.ExternalToolFailure;
                var externalError =
                    new DeveloperLogEvent.Types.ExternalToolError
                    {
                        ExitCode = ((ProcessExecutionException) e).ExitCode
                    };
                logEvent.ExternalToolError = externalError;
            }
            else
            {
                logEvent.StatusCode = DeveloperEventStatus.Types.Code.ExternalToolUnavailable;
            }
            return logEvent;
        }


        static DeveloperEventStatus.Types.Code ClassifyException(Exception e)
        {
            if (e is IInputError)
            {
                return DeveloperEventStatus.Types.Code.InvalidInput;
            }
            if (e is IConfigurationError || e is IGgpConfigurationError)
            {
                return DeveloperEventStatus.Types.Code.InvalidConfiguration;
            }
            if (e is IInvalidStateError)
            {
                return DeveloperEventStatus.Types.Code.InvalidObjectState;
            }
            if (e is OperationCanceledException)
            {
                return DeveloperEventStatus.Types.Code.CanceledSubTask;
            }
            if (e is TimeoutException)
            {
                return DeveloperEventStatus.Types.Code.Timeout;
            }
            return DeveloperEventStatus.Types.Code.UnknownStatus;
        }

        static DeveloperEventStatus.Types.Code ClassifyGrpcStatus(Status status)
        {
            switch (status.StatusCode)
            {
                // Errors that are generated by API FE, either directly or from a backend.
                // They will be further classified by the exact status code during processing.
                case StatusCode.InvalidArgument:
                case StatusCode.DeadlineExceeded:
                case StatusCode.NotFound:
                case StatusCode.AlreadyExists:
                case StatusCode.PermissionDenied:
                case StatusCode.ResourceExhausted:
                case StatusCode.FailedPrecondition:
                case StatusCode.Aborted:
                case StatusCode.OutOfRange:
                case StatusCode.Unimplemented:
                case StatusCode.Internal:
                case StatusCode.DataLoss:
                    return DeveloperEventStatus.Types.Code.CommandFailure;

                // Unauthenticated is generated on the server, before API FE.
                case StatusCode.Unauthenticated:
                    return DeveloperEventStatus.Types.Code.AuthorizationFailure;

                // Unavailable is generated on the client on connection failure (network problem).
                case StatusCode.Unavailable:
                    return DeveloperEventStatus.Types.Code.ConnectionFailure;

                // Errors that imply we did something wrong locally.
                case StatusCode.Cancelled:
                case StatusCode.Unknown:
                    return DeveloperEventStatus.Types.Code.InternalError;
            }
            return DeveloperEventStatus.Types.Code.InternalError;
        }
    }
}
